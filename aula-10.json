[
  {
    "question": "Qual é a principal finalidade de uma `interface` em TypeScript, de acordo com o material apresentado?",
    "options": [
      "Criar apelidos para tipos primitivos, como `string` ou `number`.",
      "Definir a 'forma' ou o 'contrato' que um objeto deve seguir.",
      "Unir dois ou mais tipos diferentes em um só, como `string | number`.",
      "Garantir que o valor de uma variável não possa ser alterado."
    ],
    "correct": 1,
    "feedback": [
      "Incorreto. Para criar apelidos (aliases) para tipos, a ferramenta mais versátil é o `type`. Por exemplo: `type MeuTexto = string;`.",
      "Correto! Interfaces são como plantas baixas para objetos. Elas são usadas principalmente para definir a estrutura e as propriedades que um objeto deve ter.",
      "Incorreto. A união de tipos usando o operador `|` (pipe) é uma característica dos `type` aliases. Por exemplo: `type ID = string | number;`.",
      "Incorreto. Para garantir que uma variável não possa ser reatribuída, usamos a palavra-chave `const` do JavaScript, não uma funcionalidade do sistema de tipos do TypeScript."
    ]
  },
  {
    "question": "Como uma interface `Cachorro` pode herdar as propriedades de uma interface `Animal`?",
    "options": [
      "Usando o operador de interseção: `type Cachorro = Animal & { ... }`",
      "Usando a palavra-chave `extends`: `interface Cachorro extends Animal { ... }`",
      "Usando a palavra-chave `implements`: `interface Cachorro implements Animal { ... }`",
      "Declarando a interface `Cachorro` dentro da interface `Animal`."
    ],
    "correct": 1,
    "feedback": [
      "Incorreto. O operador `&` é usado para compor `types`, não para estender `interfaces` no sentido de herança clássica. Ele cria um novo tipo que combina as propriedades de ambos.",
      "Correto! A palavra-chave `extends` é usada para que uma interface herde todas as propriedades e métodos de outra, permitindo adicionar novas especializações.",
      "Incorreto. A palavra-chave `implements` é usada por `classes` para garantir que elas sigam o contrato de uma `interface`, mas não é usada entre duas interfaces.",
      "Incorreto. Aninhar interfaces não cria uma relação de herança entre elas. A forma correta e explícita é usando `extends`."
    ]
  },
  {
    "question": "Você precisa de um tipo que aceite 'disponível', 'esgotado' ou 'descontinuado'. Qual a forma correta de criar esse tipo?",
    "options": [
      "interface StatusProduto { 'disponível', 'esgotado', 'descontinuado' }",
      "type StatusProduto = ['disponível', 'esgotado', 'descontinuado']",
      "type StatusProduto = 'disponível' | 'esgotado' | 'descontinuado'",
      "interface StatusProduto extends 'disponível', 'esgotado', 'descontinuado'"
    ],
    "correct": 2,
    "feedback": [
      "Incorreto. A sintaxe de `interface` é usada para definir a forma de objetos (com chaves e valores), não para listar valores de string permitidos.",
      "Incorreto. O uso de colchetes `[]` definiria um tipo `array` (tupla, neste caso), o que não é o objetivo. Queremos que uma variável tenha UM desses valores, não um array com todos eles.",
      "Correto! Este é um exemplo clássico de `union type` (tipo de união), onde um tipo pode ser um valor dentre vários outros. O `type` é perfeito para isso.",
      "Incorreto. A palavra-chave `extends` é usada para herdar de outra `interface`, não para listar valores permitidos."
    ]
  },
  {
    "question": "O que o operador `&` (interseção) faz quando combinamos dois tipos de objeto, como em `type A & B`?",
    "options": [
      "Cria um tipo que pode ter as propriedades de A OU as propriedades de B.",
      "Cria um tipo que deve ter TODAS as propriedades de A E TODAS as propriedades de B.",
      "Cria um tipo que terá apenas as propriedades que existem tanto em A quanto em B.",
      "Gera um erro, pois o TypeScript não permite combinar `types` dessa forma."
    ],
    "correct": 1,
    "feedback": [
      "Incorreto. Essa descrição corresponde ao operador de união `|` (pipe), que oferece flexibilidade.",
      "Correto! A interseção (`&`) combina múltiplos tipos em um só, exigindo que o objeto final tenha todas as propriedades de todos os tipos que foram combinados.",
      "Incorreto. Esse é um erro comum de interpretação. A interseção não busca o que é comum, mas sim soma todas as propriedades dos tipos envolvidos.",
      "Incorreto. O TypeScript permite e incentiva a combinação de tipos com o operador `&` como uma forma de composição."
    ]
  },
  {
    "question": "Qual das seguintes características é uma diferença chave das `interfaces` que NÃO se aplica aos `types`?",
    "options": [
      "Podem ser usadas para definir a forma de um objeto.",
      "Podem ser mescladas (Declaration Merging) se o mesmo nome for declarado mais de uma vez.",
      "Podem ser usadas em conjunto com a palavra `extends`.",
      "Podem ser utilizadas para tipar os parâmetros de uma função."
    ],
    "correct": 1,
    "feedback": [
      "Incorreto. Tanto `interfaces` quanto `types` podem definir a forma de um objeto.",
      "Correto! Apenas `interfaces` possuem a capacidade de 'Declaration Merging'. Se você declarar a mesma interface em dois lugares, o TypeScript as une. `type` não permite isso, o que o torna mais restrito e previsível.",
      "Incorreto. Embora `extends` seja idiomático para `interfaces`, os `types` podem alcançar um resultado semelhante usando o operador de interseção `&`.",
      "Incorreto. Ambos podem ser usados para tipar parâmetros de função, garantindo que os argumentos corretos sejam passados."
    ]
  },
  {
    "question": "Ao pegar um elemento do DOM com `document.querySelector('#meu-botao')`, por que é crucial verificar se o resultado é `null`?",
    "options": [
      "Porque o TypeScript exige essa verificação para compilar o código.",
      "Para garantir que o elemento HTML não tenha erros de sintaxe.",
      "Porque `querySelector` pode não encontrar o elemento, e tentar usar uma variável `null` causará um erro em tempo de execução.",
      "Para converter o tipo do elemento para `HTMLButtonElement`."
    ],
    "correct": 2,
    "feedback": [
      "Incorreto. O TypeScript não exige, mas ele te avisa do risco, tipando o retorno como `Element | null`. Ignorar esse aviso é uma má prática que pode levar a erros.",
      "Incorreto. A verificação de `null` não tem relação com a sintaxe do HTML, mas sim com a existência do elemento na árvore do DOM no momento da busca.",
      "Correto! Esta é a razão fundamental. Se o seletor estiver errado ou o elemento não existir na página, a função retornará `null`. Tentar adicionar um `addEventListener` a `null`, por exemplo, quebrará sua aplicação.",
      "Incorreto. A verificação de `null` é uma checagem de existência. A conversão de tipo é feita com `as`, mas só deve ser feita depois de garantir que o elemento não é nulo."
    ]
  },
  {
    "question": "Dentro de um `addEventListener`, por que usamos `event.target as HTMLInputElement` para acessar a propriedade `.value`?",
    "options": [
      "Para forçar o TypeScript a recarregar o elemento do DOM.",
      "É a única maneira de ler o valor de qualquer elemento HTML.",
      "Porque o tipo padrão de `event.target` é genérico e não inclui a propriedade `.value`, então precisamos afirmar seu tipo específico.",
      "Para criar uma cópia do `event.target` e evitar alterar o original."
    ],
    "correct": 2,
    "feedback": [
      "Incorreto. O `as` é uma operação de asserção de tipo em tempo de compilação, ele não tem efeito sobre o DOM em tempo de execução.",
      "Incorreto. Elementos como `div` ou `button` não possuem uma propriedade `.value`. Essa propriedade é específica de elementos de formulário, como `input`, `select`, etc.",
      "Correto! Por padrão, `event.target` é do tipo `EventTarget`, que é muito genérico. Ao usar `as HTMLInputElement`, informamos ao TypeScript: 'Confie em mim, este alvo é um elemento de input', liberando o acesso a propriedades específicas como `.value`.",
      "Incorreto. A asserção de tipo `as` não cria cópias de objetos, apenas informa ao compilador qual é o tipo esperado daquele valor."
    ]
  },
  {
    "question": "Qual é o tipo de retorno correto para uma função que realiza uma ação (ex: imprime no console) mas não retorna nenhum valor?",
    "options": [
      "void",
      "null",
      "undefined",
      "any"
    ],
    "correct": 0,
    "feedback": [
      "Correto! `void` é o tipo usado para explicitamente declarar que uma função não tem valor de retorno.",
      "Incorreto. `null` é um valor que representa a ausência intencional de um objeto. Uma função pode retornar `null`, mas `void` significa que não há retorno algum.",
      "Incorreto. `undefined` é o valor de uma variável que foi declarada mas não inicializada. Assim como `null`, é um valor, enquanto `void` é a ausência de um valor de retorno.",
      "Incorreto. Embora `any` fizesse o código compilar, ele desabilita a verificação de tipos e não descreve a intenção da função, que é não retornar nada. `void` é muito mais preciso."
    ]
  },
  {
    "question": "Dado o array `const produtos: Product[]`, qual método de array tipado seria ideal para criar um novo array contendo apenas os nomes dos produtos?",
    "options": [
      "`.filter()`",
      "`.forEach()`",
      "`.reduce()`",
      "`.map()`"
    ],
    "correct": 3,
    "feedback": [
      "Incorreto. O método `.filter()` é usado para criar um novo array com os elementos que passam em uma condição (ex: produtos com preço &gt 100). Ele não transforma os elementos.",
      "Incorreto. O método `.forEach()` é usado para executar uma ação para cada elemento do array, mas ele não retorna um novo array.",
      "Incorreto. Embora seja possível usar `.reduce()` para isso, ele é mais complexo e sua principal finalidade é 'reduzir' o array a um único valor (como uma soma total).",
      "Correto! O método `.map()` é perfeito para isso. Ele cria um novo array com o mesmo número de elementos, onde cada elemento é o resultado da função de callback. Transformar um `Product` em uma `string` (seu nome) é o caso de uso ideal."
    ]
  },
  {
    "question": "Como se define uma propriedade opcional chamada `desconto` em uma interface `Produto`?",
    "options": [
      "`desconto: string | undefined;`",
      "`optional desconto: string;`",
      "`desconto?: number;`",
      "`&ltdesconto&gt: number;`"
    ],
    "correct": 2,
    "feedback": [
      "Incorreto. Embora na prática uma propriedade opcional possa ser `undefined`, a sintaxe correta e idiomática para declará-la na interface é usando o `?`.",
      "Incorreto. A palavra-chave `optional` não existe com essa finalidade no TypeScript.",
      "Correto! O ponto de interrogação `?` colocado antes dos dois pontos `:` indica que a propriedade é opcional. Objetos que seguem essa interface podem ou não ter essa propriedade.",
      "Incorreto. O uso de `&lt &gt` (chevrons) é para Generics, não para definir propriedades opcionais."
    ]
  }
]
