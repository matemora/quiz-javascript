[
    {
        "question": "Qual é a principal vantagem de usar `element.addEventListener()` em vez de `element.onclick` diretamente no JavaScript?",
        "options": [
            "É a única forma de fazer um elemento ser clicável.",
            "Permite adicionar múltiplos 'ouvintes' de eventos para o mesmo evento em um único elemento.",
            "O código fica menor e mais simples de escrever.",
            "Funciona melhor para eventos de teclado, mas não para eventos de mouse."
        ],
        "correct": 1,
        "feedback": [
            "Incorreto. É possível tornar um elemento clicável de outras formas, como com `onclick`, mas `addEventListener` é mais flexível.",
            "Correto. A grande vantagem do `addEventListener` é que ele permite que várias funções sejam executadas para o mesmo evento, sem que uma sobrescreva a outra. Isso torna o código mais modular e escalável.",
            "Incorreto. A sintaxe do `addEventListener` é um pouco mais longa que a do `onclick`, mas seus benefícios em organização e flexibilidade compensam.",
            "Incorreto. `addEventListener` funciona igualmente bem para todos os tipos de eventos, sejam eles de mouse, teclado, formulário, etc."
        ]
    },
    {
        "question": "Em qual situação o uso de `event.preventDefault()` é mais comum e essencial?",
        "options": [
            "Para impedir que um `&lt;div&gt;` mude de cor ao ser clicado.",
            "Para parar a execução de uma função `setTimeout`.",
            "Ao lidar com o evento `submit` de um `&lt;form&gt;` para evitar que a página seja recarregada.",
            "Para evitar que o evento `mouseover` seja disparado múltiplas vezes."
        ],
        "correct": 2,
        "feedback": [
            "Incorreto. Mudar a cor de um `&lt;div&gt;` não é um comportamento padrão do navegador, então `preventDefault()` não teria efeito nesse caso.",
            "Incorreto. Para parar um `setTimeout`, você deve usar a função `clearTimeout()`.",
            "Correto. O comportamento padrão de um formulário ao ser submetido é enviar os dados e recarregar a página. `event.preventDefault()` é fundamental para interceptar esse processo e manipular os dados com JavaScript (ex: via AJAX) sem um refresh completo.",
            "Incorreto. `preventDefault()` não impede que um evento seja disparado, ele apenas bloqueia a ação padrão do navegador associada àquele evento."
        ]
    },
    {
        "question": "Dentro de uma função de callback de evento, o que o `event.target` representa?",
        "options": [
            "O elemento ao qual o `addEventListener` foi anexado.",
            "A janela do navegador (o objeto `window`).",
            "O elemento exato que originou o disparo do evento.",
            "O nome do evento que foi disparado (ex: 'click')."
        ],
        "correct": 2,
        "feedback": [
            "Incorreto. Isso descreve o `event.currentTarget`. São diferentes quando usamos o conceito de propagação de eventos (event bubbling).",
            "Incorreto. A janela do navegador é representada pelo objeto `window` e não pelo `event.target`.",
            "Correto. `event.target` é uma propriedade extremamente útil que aponta para o nó do DOM específico que iniciou o evento. Por exemplo, se você tem um 'ouvinte' em uma `&lt;ul&gt;`, mas o clique foi em um `&lt;li&gt;` dentro dela, o `event.target` será o `&lt;li&gt;`.",
            "Incorreto. O nome do evento é obtido através da propriedade `event.type`."
        ]
    },
    {
        "question": "Os dados salvos com a Web API `localStorage` persistem por quanto tempo?",
        "options": [
            "Até que a aba do navegador seja fechada.",
            "Até que o navegador seja fechado.",
            "Permanentemente, ou até que os dados do navegador sejam limpos pelo usuário ou pela aplicação.",
            "Por 24 horas, após isso são automaticamente deletados."
        ],
        "correct": 2,
        "feedback": [
            "Incorreto. Isso descreve o comportamento do `sessionStorage`, não do `localStorage`.",
            "Incorreto. Fechar e reabrir o navegador não apaga os dados do `localStorage`.",
            "Correto. O `localStorage` não possui tempo de expiração. Os dados ficam armazenados indefinidamente no dispositivo do usuário, a menos que sejam removidos ativamente via código (`localStorage.removeItem()` ou `localStorage.clear()`) ou pela limpeza de cache do navegador.",
            "Incorreto. Não há um mecanismo de expiração automática no `localStorage`."
        ]
    },
    {
        "question": "Qual é a diferença fundamental entre `setTimeout` e `setInterval`?",
        "options": [
            "`setTimeout` executa uma função repetidamente; `setInterval` executa apenas uma vez.",
            "`setTimeout` executa uma função uma única vez após um delay; `setInterval` executa uma função repetidamente em um intervalo de tempo.",
            "Ambos fazem a mesma coisa, mas `setInterval` tem uma sintaxe mais moderna.",
            "`setTimeout` só aceita funções anônimas, enquanto `setInterval` aceita funções nomeadas."
        ],
        "correct": 1,
        "feedback": [
            "Incorreto. Esta é a definição invertida.",
            "Correto. `setTimeout` é como um 'despertador' que toca uma vez. `setInterval` é como um alarme que toca 'a cada hora', continuamente, até que seja cancelado com `clearInterval()`.",
            "Incorreto. Eles têm propósitos fundamentalmente diferentes e ambos são amplamente utilizados.",
            "Incorreto. Ambos aceitam tanto funções anônimas quanto nomeadas como seu primeiro argumento."
        ]
    },
    {
        "question": "Web APIs como DOM API, Fetch API e Geolocation API são consideradas:",
        "options": [
            "Parte do núcleo da linguagem JavaScript (ECMAScript).",
            "Funcionalidades fornecidas pelo ambiente do navegador para o JavaScript interagir.",
            "Atributos que só podem ser usados diretamente em tags HTML.",
            "APIs que só funcionam no ambiente Node.js para interagir com o servidor."
        ],
        "correct": 1,
        "feedback": [
            "Incorreto. O JavaScript por si só não sabe o que é um 'documento' ou como fazer uma requisição de rede. Essas funcionalidades não estão na especificação da linguagem.",
            "Correto. As Web APIs são 'superpoderes' que o ambiente (neste caso, o navegador) concede ao JavaScript, permitindo que ele manipule a página, faça requisições, acesse a localização, etc.",
            "Incorreto. Elas são interfaces acessadas e controladas através de código JavaScript, não de atributos HTML.",
            "Incorreto. Estas são especificamente APIs do lado do cliente (navegador). Node.js tem seu próprio conjunto de APIs, como `fs` e `http`."
        ]
    },
    {
        "question": "Para capturar a digitação do usuário em um campo `&lt;input&gt;` em tempo real, qual evento é o mais indicado?",
        "options": [
            "change",
            "submit",
            "click",
            "input"
        ],
        "correct": 3,
        "feedback": [
            "Incorreto. O evento `change` só é disparado quando o usuário altera o valor E o elemento perde o foco (ex: clica fora do campo), não em tempo real.",
            "Incorreto. O evento `submit` é disparado no formulário (`&lt;form&gt;`) inteiro, não no campo `&lt;input&gt;`, e apenas na tentativa de envio.",
            "Incorreto. O evento `click` detecta um clique do mouse, não a digitação.",
            "Correto. O evento `input` é disparado instantaneamente toda vez que o valor de um `&lt;input&gt;` ou `&lt;textarea&gt;` é alterado, sendo perfeito para funcionalidades de busca em tempo real, contadores de caracteres, etc."
        ]
    },
    {
        "question": "O que é necessário para remover um 'ouvinte' de evento com `removeEventListener` com sucesso?",
        "options": [
            "Apenas passar o nome do evento, como 'click'.",
            "Passar o nome do evento e a mesma referência da função nomeada que foi usada no `addEventListener`.",
            "Usar uma função anônima, pois elas são removidas automaticamente.",
            "Chamar `removeEventListener` sem argumentos."
        ],
        "correct": 1,
        "feedback": [
            "Incorreto. O navegador precisa saber qual função específica deve ser removida para aquele evento.",
            "Correto. Para que a remoção funcione, você deve passar para o `removeEventListener` exatamente a mesma função que foi passada para o `addEventListener`. É por isso que, ao planejar remover um 'ouvinte', devemos usar funções nomeadas em vez de anônimas.",
            "Incorreto. Funções anônimas não podem ser referenciadas posteriormente, tornando impossível removê-las com `removeEventListener`.",
            "Incorreto. Isso resultaria em um erro, pois o método requer o tipo de evento e a função a ser removida."
        ]
    },
    {
        "question": "Qual evento devemos 'escutar' para executar um script JavaScript assim que a estrutura HTML da página for carregada, sem esperar por imagens e CSS?",
        "options": [
            "load",
            "DOMContentLoaded",
            "scroll",
            "unload"
        ],
        "correct": 1,
        "feedback": [
            "Incorreto. O evento `load` espera que TUDO na página seja carregado, incluindo imagens, iframes e folhas de estilo, o que pode atrasar a execução do script.",
            "Correto. `DOMContentLoaded` é o evento ideal para iniciar a manipulação do DOM. Ele é disparado assim que o documento HTML principal foi completamente carregado e parseado, sem aguardar por recursos externos, tornando a página interativa mais rapidamente.",
            "Incorreto. O evento `scroll` é disparado quando o usuário rola a página.",
            "Incorreto. O evento `unload` é disparado quando a página está sendo descarregada."
        ]
    },
    {
        "question": "A API `fs` (File System), usada para ler e escrever arquivos no disco, é um exemplo de qual tipo de API?",
        "options": [
            "Web API, pois a web precisa de arquivos.",
            "Node API, pois interage com o sistema de arquivos do servidor ou da máquina.",
            "CSS API, para manipular arquivos de estilo.",
            "DOM API, pois gerencia arquivos dentro do `document`."
        ],
        "correct": 1,
        "feedback": [
            "Incorreto. Por razões de segurança, o JavaScript que roda em um navegador (Web API) não tem permissão para acessar o sistema de arquivos do usuário diretamente.",
            "Correto. A API `fs` é uma das APIs centrais do Node.js. Ela fornece ao JavaScript, quando rodando no ambiente de servidor (back-end), a capacidade de interagir com o sistema de arquivos, algo que é impossível no ambiente do navegador.",
            "Incorreto. Não existe uma 'CSS API' para manipulação de arquivos; o CSS é gerenciado e aplicado pelo navegador.",
            "Incorreto. A DOM API gerencia a estrutura da página HTML (o `document`), não os arquivos no disco do computador."
        ]
    }
]
